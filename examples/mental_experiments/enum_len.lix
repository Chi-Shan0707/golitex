enum 和 len 是建立数数和有限集合的大小的桥梁

比如已知 s = {1,2,3} 我作为人知道 len(s) = 3
但 match + substitution 无法证明 len(s) = 3，因为集合长度是字面量信息

当然你可以直接 know len(s) = 3，这样在你没有枚举元素的情况下去知道len而不清楚如何枚举元素

所以相关的逻辑我需要内置

内置方式：如果我know了 enum s : 1,2,3，那我自动生成 1. len(s) $in N 2. s $is_finite_set 2. len(s) = 3

这是从 字面量到 len(s) 这种自由函数的桥梁

有了len这个定义域是有限集合集合，返回值是N的集合,其他所有的和 数数 相关的逻辑，都能用 match+substitution 证明了。 也就是说排列组合里面的定理应该都能表达了

集合上面的其他的prop和fn，都是标准库内容，并不是内核的内容。比如union之类的

这个 len 的处理上的和普通的匹配和替换不一样的地方，本质上和 C 语言访问越界是一个原理。一个简单的ptr不能完全确定这个array，因为不知道涉及到的array的长度是多少。所以要写成 struct {*ptr; len: N} 这种形式。每次你往这个ptr后面append新的值的时候，len需要++（这就和 len(s) =N ,len(s \union {x}) = N+1 这种逻辑一样）。或者，你一开始就指定好这个ptr的长度比如 struct {*ptr; len: 3} 这种形式，(类似litex的 enum: 1,2,3，这时候我立刻推断出来len(3)=3)。array里的东西的存储，和array长度，是本质上两片信息。

所以，普通的匹配和替换是不能”数数“的，即不能判断出来enum s:1,2,3里有多少个元素。这样的信息来自更高维度的控制（比如人眼是比纸上写的符号更高维度的东西，图灵机的指针比指代要高维度）。

CPU里，加减乘除是内置的；array的可访问的长度，在C语言之后的语言里，都用struct{ptr*, len: N} 这种形式来表示了（解决array访问越界）。应该说，litex已经把日常我们熟悉的所有的，计算机能表示的东西，都安全地提供给用户了；虽然litex不是编程语言，但是越是能表示正常编程语言里呢个表达的东西，说明它语义越丰富，就说明它越是能”表达所有数学“。

相当于我要把汇编语言里的简单运算（加减乘除）+ 内存安全的语言的数据结构（slice），送给用户。一旦他们有这些语言特性了，他们就够表达所有数学了。












