prove:
    know:
        forall x nat:
            forall y nat:
                $p(x,y)
            iff:
                forall y nat:
                    $q(x,y)
            
        forall x nat, y nat:
            $p(x,y)

    forall x nat, y nat:
        $q(x,y)

prove:
    know a = 1
    a = 1

prove:
    know:
        or:
         a = 1
         b =2 
        not a = 1

    
    b = 2

prove:
    know:
        forall x nat:
            $p(x)

    $p(1)

prove:
    prop p(x nat):
        or:
            $q(x)
            $r(x)
    
    know $p(1)
    know not $q(1)
    $r(1)

prove:
    fn f(x nat) nat:
        $p(x)

    $in(f, fn)

    prop p(x nat):
        $q(x)

    $in(p, prop)

prove:
    fn line_of(a point, b point) line:
        a != b
        then:
            $point_on_line(line_of(a, b), a)
            $point_on_line(line_of(a, b), b)
            forall l line:
                $point_on_line(a, l)
                $point_on_line(b, l)
                then:
                    l = line_of(a, b)

    
prove:
    know:
        forall x nat:
            or:
                $p(x)
                $q(x)
    

        forall x nat:
            dom:
                forall y nat:
                    $q(x, y)
            $p(x)
    
        和 下面这个逻辑上一样，但语义不一样

        下面这么写的话，这个forall是不会帮到我验证的，因为我找不到y
        forall x nat, y nat:
            dom:
                $q(x, y)
            then:
                $p(x)    
        
        当然我不能让你 forall 套超过2层，因为我搜索的时候是 n^2 量级，3层就是 n^3 了

        golang 的 内部的 interface 从来没超过一层，我的语言也是
