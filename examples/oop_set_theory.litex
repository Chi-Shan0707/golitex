concept object {}
concept set {
  relation has(x) {}
  
  static relation =(x, y): x is set, y is set {
   iff =(x,y) <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)};
   /* iff this <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)}; */
  }

  /*
  static relation =(x, y): all x,y are set {
    if x,y: all x,y are set {iff =(x,y) <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)} };
  }
  */

  static var empty_set {
    know empty_set is set;
    if x: {not x empty_set.has(x)};
  }
}

fn static set::singleton(a)  => var {
  this is set;
  if z: this.has(z) {a = z};
  this.has(a);
}

fn static set::pair(a,b) => var {
  this is set;
  this.has(a,b);
  if z: this.has(z) {
    z = b or z = a
  };
}

fn static set::union(a, b: all a,b are set) => var {
  this is set;
  if z: this.has(z) {
    a.has(z) or b.has(z)
  }
}

relation static set::subset(a, b: all a,b are set)  {
  know if z: a.has(z) {b.has(z)}
}

fn static set::specification(A, relation P(x: A.has(x)): A is set, ) => concept {
  know exist this;
}

fn static set::intersection(a,b: all a,b are set) => var {
  iff z: this.has(z) <=> {a.has(z), b.has(z)}
}

// P2 means fix the second parameter
fn P2($P, z): P.parameters_number == 2 => relation(y) {
  iff y: this(x) <=> $P(x, z)
}

fn replacement($P, A: A is set) => concept {
  this is set;
  iff z: this.has(z) {
    exist P2($P, z)
  }
}

know if A, $P: A is set, $P.parameters_number == 2, A.has($P.parameter[0]),
if x, y1,y2: $P(x, y1), $P(x, y2) {y1 = y2} {
  exist replacement($P, A)
}

know if A: A is set, A != set::empty_set {
  exist x: not x is set or set::intersection(x,A) = set::empty_set;
}