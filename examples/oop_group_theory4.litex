concept Group G {
  // 定义运算
  fn *(G x, G y) G;
  fn inv(G x) G;

  // 定义单位元
  var G 1;

  // 结合律
  if G x, G y : (x * y) * z = x * (y * z);
  ∀ G x, G y, G z {...extra requirements} : x * y * z = x * (y * z);

  // 单位元性质
  ∀ G x {}: x * G.1 = x , G.1 * x = x;

  // 逆元性质
  ∀ G x {}: inv(x) * x = G.1 , x * inv(x) = G.1;
}

Property abelian of Group G {
  if G x, G y {
    x * y = y * x;
  }
}

property abelian of Group G:
  if G x, G y:
    x * y = y * x

concept AbelianGroup G extends Group {
  axioms {
    ∀ G x, G y {...extra requirements} : x * y = y * x;
  }
}

concept Monoid M {
  fn *(M x, M y) M;
  var M 1;

  axioms {
    ∀ M x, M y: x * y * z = x * (y * z);
    ∀ M x: 1 * x = x , x * 1 = x;
  }
}

concept Semigroup S {
  fn *(S x, S y) S;

  axioms {
    ∀ S x, S y: x * y * z x * (y * z);
  }
}

property 单射(fn F) {
  ∀ var x1, var x2: F(x1) = F(x2) {x1 = x2};
}

concept 满射 F extends fn {
  axioms {
    ∀ var y {$F.image.has(x)}: exist var x: F(x) = y;
  }
}

/* functional version of group_transformation

fn group_transformation(Group G, G a) fn F(G x) G {
  group_transformation(G, a)(x) = a * x;
}

prove if Group G, G a: {$单射(group_transformation(G, a))} {
  ....
}

*/

fn group_transformation<Group G, G a>(G x) G {
  group_transformation<G, a>(x) = a * x;
}


prove if Group G, G a : {$单射(group_transformation<G, a>(G x) F)} {
  if var x1, var x2: F(x1) = F(x2) {
    a * x1 = F(x1);
    a * x2 = F(x2);
    a * x1 = a * x2;
    inv(a) * (a * x2) = inv(a) * (a * x1) //解释器会 ”猜测“你是怎么得到的，比如compare 里面的opt本身和顺序是正确的，参数也是一样的
    => (inv(a) * a) * x2 = (inv(a) * a) * x1;
    => 1 * x2 = 1 * x1;
    => x2 = x1;
  }
}

prove if Group G, G a, G b: a * b = G.1 {b = inv(a)} {
  inv(a) * (a * b) = inv(a) * G.1
  => (inv(a) * a) * b = inv(a) // 用 => 表示此时新式子的左边等于原来的左边；原来的右边等于原来的右边
  => 1 * b = inv(a)
  => b = inv(a);

  // 或者
  inv(a) * (a * b) = inv(a) * G.1;
  inv(a) * (a * b) = (inv(a) * a) * b = G.1 * b = b;
  inv(a) * G.1 = inv(a);
  b = inv(a);
}

prove if Group G, G a, G b : inv(a * b) = inv(b) * inv(a); {
  (a * b) * (inv(b) * inv(a)) = ((a * b) * inv(b)) * inv(a) = 
  (a * (b * inv(b))) * inv(a) = (a * G.1) * inv(a) = a * inv(a) = G.1
  (inv(b) * inv(a)) = inv(a * b)
}