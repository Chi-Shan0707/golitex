import {
  KnowNode,
  L_Node,
  LetNode,
  OptNode,
  IfThenNode,
  FactNode,
  OrNode,
  DeclNode,
  IffDeclNode,
  IfThenDeclNode,
  ProveNode,
  ExistNode,
  HaveNode,
  AssumeByContraNode,
  OnlyIfDeclNode,
  LogicalOptNode,
  IffNode,
  OnlyIfNode,
  ByNode,
} from "./ast";
import { L_Env } from "./env";
import { checker } from "./L_Checker";
import { L_Builtins } from "./builtins";
import { L_Saver } from "./L_Saver";

export enum RType {
  Error,
  True, // not only used as True for callInferExec, but also as a generic type passed between subFunctions.
  KnowUndeclared,
  False,
  Unknown,
  HaveFailed,
  ProveFailed,
  ThmFailed,
}

export const RTypeMap: { [key in RType]: string } = {
  [RType.Error]: "error",
  [RType.False]: "check: false",
  [RType.True]: "check: true",
  [RType.Unknown]: "check: unknown",
  [RType.KnowUndeclared]: "know: undeclared opt",
  [RType.HaveFailed]: "have: failed",
  [RType.ProveFailed]: "prove: failed",
  [RType.ThmFailed]: "thm: failed",
};

function handleExecError(env: L_Env, out: RType, m: string = "") {
  env.newMessage(m);
  return out;
}

/**
 * Guideline of what execute functions do
 * 1. return RType thing
 * 2. env.newMessage()
 */
export namespace L_Executor {
  const nodeExecMap: { [key: string]: (env: L_Env, node: any) => RType } = {
    IffDeclNode: declExec,
    IfThenDeclNode: declExec,
    ExistNode: declExec,
    OnlyIfDeclNode: declExec,
    KnowNode: knowExec,
    LetNode: letExec,
    ProveNode: proveExec,
    HaveNode: haveExec,
    AssumeByContraNode: assumeByContraExec,
    ByNode: _byExec,
  };

  export function nodeExec(env: L_Env, node: L_Node): RType {
    try {
      const nodeType = node.constructor.name;
      const execFunc = nodeExecMap[nodeType];

      if (execFunc && execFunc(env, node) === RType.True)
        return successMesIntoEnv(env, node);
      else if (node instanceof FactNode) {
        try {
          // const out = factExec(env, node as FactNode);
          // return out;

          const out = factExec(env, node as FactNode);
          // const out = yaFactExec(env, node as FactNode);
          if (out === RType.True) {
            env.newMessage(`OK! ${node}`);
          } else if (out === RType.Unknown) {
            env.newMessage(`Unknown ${node}`);
          } else if (out === RType.Error) {
            env.newMessage(`Error ${node}`);
          }
          return out;
        } catch (error) {
          throw Error(`${node as FactNode}`);
        }
      }
      return RType.Error;
    } catch (error) {
      if (error instanceof Error) env.newMessage(`Error: ${error.message}`);
      return RType.Error;
    }
  }

  function successMesIntoEnv(env: L_Env, node: L_Node): RType {
    env.newMessage(`OK! ${node.toString()}`);
    return RType.True;
  }

  //! Here is where a new fact is generated by previous facts
  /**
   * Steps
   * 1. check fact
   * 2. know new fact
   */
  // function factExec(env: L_Env, node: FactNode): RType {
  //   try {
  //     if (node instanceof OptNode) {
  //       const func = L_Builtins.get(node.fullName);
  //       if (func) return func(env, node);
  //     }

  //     const res = checker.check(env, node as FactNode);
  //     if (res.type === RType.True) {
  //       if (res.checkedByOpt === false) knowExec(env, new KnowNode([node]));
  //       return successMesIntoEnv(env, node);
  //     } else if (res.type === RType.Unknown) {
  //       env.newMessage(`Unknown. ${node.toString()}`);
  //       return RType.Unknown;
  //     } else if (res.type === RType.False) {
  //       env.newMessage(`False. ${node.toString()}`);
  //       return RType.False;
  //     } else if (res.type === RType.Error) {
  //       env.newMessage(`Error: ${node.toString()}`);
  //       return RType.Error;
  //     }
  //     return RType.Error;
  //   } catch (error) {
  //     env.newMessage(`Error: ${node.toString()}`);
  //     return RType.Error;
  //   }
  // }

  function haveExec(env: L_Env, node: HaveNode): RType {
    try {
      // Check duplicate variable declarations
      const noErr = env.declareNewVar(node.vars);
      if (!noErr) {
        env.newMessage(
          `Error: Variable(s) ${node.vars.join(", ")} already declared in this scope.`
        );
        return RType.Error;
      }

      for (const fact of node.facts) {
        if (fact instanceof OptNode) {
          const out = checker.checkOptInHave(env, fact);
          if (out !== RType.True) {
            env.newMessage(`Unknown: ${node.toString()}`);
            return out;
          }
        } else {
          //! For the time being, if-then can not be checked when have
          env.newMessage(`Error: ${node.toString()}`);
          return RType.Error;
        }
      }

      knowExec(env, new KnowNode(node.facts));

      return RType.True;
    } catch (error) {
      env.newMessage(`Error: ${node.toString()}`);
      return RType.Error;
    }
  }

  function letExec(env: L_Env, node: LetNode): RType {
    try {
      // ya ya: put new vars into env
      node.vars.forEach((e) => env.newFreeFix(e, e));

      // Check duplicate variable declarations
      const noErr = env.declareNewVar(node.vars);
      if (!noErr) {
        env.newMessage(
          `Error: Variable(s) ${node.vars.join(", ")} already declared in this scope.`
        );
        return RType.Error;
      }

      knowExec(env, new KnowNode(node.facts));

      return RType.True;
    } catch (error) {
      env.newMessage(`Error: ${node.toString()}`);
      return RType.Error;
    }
  }

  /**
   * Main Function of whole project. Not only used at assume expression, other expressions which introduces new fact into environment calls this function.
   *
   * know Opt: store directly
   * know if-then: if then is Opt, store it bound with if as req; if then is if-then, inherit father req and do knowExec again.
   */
  //! This one of the functions in which new facts are generated.
  //! In order to unify interface, after checking a fact, we use KnowExec to emit new fact
  export function knowExec(env: L_Env, node: KnowNode | FactNode): RType {
    try {
      if (node instanceof FactNode) {
      } else if (node instanceof KnowNode) {
        for (const fact of node.facts) {
          L_Saver.L_Store(env, fact, []);
        }
      }

      return RType.True;
    } catch (error) {
      let m = `'${node.toString()}'`;
      if (error instanceof Error) m += ` ${error.message}`;
      env.newMessage(m);
      throw error;
    }
  }

  function declExec(env: L_Env, node: DeclNode): RType {
    try {
      if (env.getDeclFact(node.name)) {
        throw Error(`${node.name} already declared.`);
      }

      env.setDeclFact(node.name, node);

      // new new storage system
      L_Saver.declNewFact(env, node);
      // L_Saver;

      return RType.True;
    } catch (error) {
      let m = `'${node.toString()}'`;
      if (error instanceof Error) m += ` ${error.message}`;
      env.newMessage(m);
      throw error;
    }
  }

  function proveExec(env: L_Env, node: ProveNode): RType {
    const newEnv = new L_Env(env);
    if (node.toProve !== null) {
      // prove vanilla if-then
      newEnv.declareNewVar(node.toProve.vars);
      knowExec(newEnv, new KnowNode(node.toProve.req));
      // execute prove block
      for (const subNode of node.block) {
        const out = nodeExec(newEnv, subNode);
        if (out !== RType.True) {
          return handleExecError(
            env,
            out,
            `Proof Block Expression ${subNode} failed.`
          );
        }
      }

      // check
      for (const toTest of node.toProve.onlyIfs) {
        const out = checker.check(newEnv, toTest);
        if (!(out.type === RType.True)) {
          return handleExecError(
            env,
            out.type,
            `Proof failed to prove ${toTest}.`
          );
        }
      }

      // store new fact into env
      node.toProve.hashVars(node.toProve.vars);
      knowExec(
        env,
        new KnowNode([
          new IfThenNode(
            node.toProve.vars,
            node.toProve.req,
            node.toProve.onlyIfs
          ),
        ])
      );

      return RType.True;
    } else if (node.fixedIfThenOpt !== null) {
      // prove declared opt
      const originalDeclFact = env.getDeclFact(node.fixedIfThenOpt.fullName);
      if (originalDeclFact === undefined) {
        return handleExecError(
          env,
          RType.Error,
          `${node.fixedIfThenOpt.fullName} is not declared.`
        );
      }

      // We must create a new declFact to avoid overwriting original declFact when hashing and removing hashes. The reason is that if we directly change the original declFact, storedFacts are changed because they are referenced to original declFact.
      const declFact = new IfThenDeclNode("", [], [], []);
      originalDeclFact.copyTo(declFact);
      declFact.rmvHashFromVars(declFact.vars);

      if (!(declFact instanceof IfThenDeclNode)) {
        return handleExecError(
          env,
          RType.Error,
          `${node.fixedIfThenOpt.fullName} is not if-type operator.`
        );
      }

      // Replace all free variables in the declared node with the given variables
      const originalOptVars = [...node.fixedIfThenOpt.vars];

      // eliminate # so that user don't need to type #
      for (let i = 0; i < node.fixedIfThenOpt.vars.length; i++) {
        if (node.fixedIfThenOpt.vars[i].startsWith("#"))
          node.fixedIfThenOpt.vars[i] = node.fixedIfThenOpt.vars[i].slice(1);
      }
      declFact.replaceVars(node.fixedIfThenOpt);

      // declare variables into newEnv
      newEnv.declareNewVar(node.fixedIfThenOpt.vars);

      // Assume all requirements of given operator is true
      knowExec(newEnv, new KnowNode(declFact.req));

      // execute prove block
      for (const subNode of node.block) {
        const out = nodeExec(newEnv, subNode);
        if (out !== RType.True) {
          return handleExecError(
            env,
            out,
            `Proof Block Expression ${subNode} failed.`
          );
        }
      }

      // check
      for (const toTest of declFact.onlyIfs) {
        const out = checker.check(newEnv, toTest);
        if (!(out.type === RType.True)) {
          return handleExecError(
            env,
            out.type,
            `Proof failed to prove ${toTest}.`
          );
        }
      }

      // store new fact into env
      node.fixedIfThenOpt.vars = originalOptVars;
      knowExec(env, new KnowNode([node.fixedIfThenOpt]));

      return RType.True;
    }

    return RType.Error;
  }

  /**
   * Steps
   * 1. open new Env
   * 2. assume node.assume
   * 3. run block
   * 4. check node.contradict, not node.contradict
   * 5. emit the reverse of node.assume
   */
  function assumeByContraExec(env: L_Env, node: AssumeByContraNode): RType {
    try {
      const newEnv = new L_Env(env);
      knowExec(newEnv, new KnowNode([node.assume]));
      for (const subNode of node.block) {
        const out = nodeExec(newEnv, subNode);
        if (out !== RType.True) {
          return handleExecError(
            env,
            out,
            `Proof Block Expression ${subNode} Failed.`
          );
        }
      }

      let out = checker.check(newEnv, node.contradict);
      if (!(out.type === RType.True)) {
        return handleExecError(
          env,
          out.type,
          `assume_by_contradiction failed to prove ${node.contradict}. Proof by contradiction requires checking both the statement and its negation.`
        );
      }

      node.contradict.isT = !node.contradict.isT;
      out = checker.check(newEnv, node.contradict);
      if (!(out.type === RType.True)) {
        return handleExecError(
          env,
          out.type,
          `assume_by_contradiction failed to prove ${node.contradict}. Proof by contradiction requires checking both the statement and its negation.`
        );
      }

      node.assume.isT = !node.assume.isT;
      knowExec(env, new KnowNode([node.assume]));
      return RType.True;
    } catch (error) {
      env.newMessage(`${node}`);
      return RType.Error;
    }
  }

  function _byExec(env: L_Env, node: ByNode): RType {
    const newEnv = new L_Env(env);
    for (const subNode of node.block) {
      const out = nodeExec(newEnv, subNode);
      if (out !== RType.True) return out;
    }
    for (const fact of node.facts) {
      const out = nodeExec(newEnv, fact);
      if (out !== RType.True) return out;
    }
    knowExec(env, new KnowNode(node.facts));
    return RType.True;
  }

  function factExec(env: L_Env, toCheck: FactNode): RType {
    try {
      let out = checker.L_Check(env, toCheck);
      if (out === RType.True) {
        L_Saver.L_Store(env, toCheck, []);
      }
      return out;
    } catch (error) {
      env.newMessage(`failed to check ${toCheck}`);
      return RType.Error;
    }
  }
}
