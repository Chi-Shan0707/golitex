# Version 1: 2025-06-14

# This is first try to formalize the book. Because the kernel has implemented finite sequence, and it is relatively hard to define finite sequence in pure litex code (and more importantly, it is not necessary because soon I implement the kernel to support finite sequence), sometimes when it comes to definitions on "a finite sequence of numbers", I suppose the finite sequence has exactly 2 elements. For example, mutually prime sequence is defined as a finite sequence of numbers, and each number is a prime number, and the two numbers are mutually prime. In my case, I just define a finite sequence as a pair of numbers.

# Since this is version 1, I do not prove anything. I just formalize all the propositions and definitions and "know" they are true.

"""
Basics
"""

forall x R, a R, b R:
    a + x = b
    then:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    then:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        then:
            b - a > 0

    forall a R, b R:
        b > a
        then:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        then:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    iff:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know exist_prop x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    iff:
        x $in s
        $is_smallest_element_of(x, s)
    

"""
Chapter 1
"""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    obj x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        then:
            b / a $in Q

"""
Chapter 2
"""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know exist_prop q Z st exist_largest_multiple_of(d Z, a Z):
    iff:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know exist_prop m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    iff:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        then:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        then:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        then:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z:
    d != 0
    a $is_divisible_by d
    b $is_divisible_by d
    then:
        gcd(a, b) $is_divisible_by d

# Definition 1

fn gcd(b Z, c Z) N:
    gcd(b, c) >= 0


"""
Chapter 3
"""

prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

know forall a Z, b Z:
    gcd(a, b) = 1
    iff:
        exist_relatively_prime(a, b)

