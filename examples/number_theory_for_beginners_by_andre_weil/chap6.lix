"""
Chapter 6
"""

import "util.lix"
import "basics.lix"
import "chap1.lix"
import "chap2.lix"
import "chap3.lix"
import "chap4.lix"
import "chap5.lix"

# Definition 6.1
# Definition of ring
prop is_unary_ring(ring set, add fn(ring, ring)ring, mul fn(ring, ring)ring, inv fn(ring)ring, add_e ring, mul_e ring):
    $is_commutative_group(ring, add, inv, add_e)
    forall a ring, b ring, c ring:
        add(mul(a, b), mul(a, c)) = mul(a, add(b, c))
        mul(a, mul(b, c)) = mul(mul(a, b), c)
        mul(a, b) = mul(b, a)
    forall a ring:
        mul(a, mul_e) = a
        mul(mul_e, a) = a


# Definition of cc_mul
fn cc_mul(m Z) fn(cc_mod(m), cc_mod(m))cc_mod(m):
    m > 0
    then:
        forall x N, y N:
            x < m
            y < m
            then:
                cc(x * y, m) = cc(x, m) \cc_mul(m) cc(y, m)

# Theorem 6.1
# For any integer m > 0, the set cc(m) is a unary ring under addition and multiplication modulo m
know forall m Z:
    m > 0
    then:
        $is_unary_ring(cc_mod(m), cc_add(m), cc_mul(m), cc_inv(m), cc(0, m), cc(1, m))

# Theorem 6.2
# Let m, a, b be with m > 0, put d = gcd(a,m), then the congruence ax = b (mod m) has either exactly d solutions modulo m, or no solution; it has a solution iff b = 0 (mod d); there are exactly m/d distinct values of b modulo m for which this is so.

fn solutions_of_congruence(a Z, b Z, m Z) set:
    forall x solutions_of_congruence(a, b, m):
        x $in Z
        $is_congruent_modulo(a * x, b, m)
    forall x Z:
        $is_congruent_modulo(a * x, b, m)
        then:
            x $in solutions_of_congruence(a, b, m)

fn solutions_of_congruence_modulo(a Z, b Z, m Z) finite_set:
    forall x solutions_of_congruence(a, b, m):
        x > 0
        x < m
        x $in solutions_of_congruence(a, b, m)
    forall x Z:
        x > 0
        x $in solutions_of_congruence(a, b, m)
        x < m
        then:
            x $in solutions_of_congruence_modulo(a, b, m)

know prop solutions_of_congruence_is_finite(a Z, b Z, m Z):
    or:
        len(solutions_of_congruence_modulo(a, b, m)) = 0
        len(solutions_of_congruence_modulo(a, b, m)) = gcd(a, m)

# TODO: ax=b (mod m) has a solution iff b = 0 (mod d). there are exactly m/d distinct values of b modulo m for which this is so.

# Corollary 6.1
# The congruence classes prime to m modulo m make up a group under multiplication
fn cc_prime_to(m Z) finite_set:
    forall x cc_prime_to(m):
        x $in cc_mod(m)
        $is_cc_prime_to_modulo(m, x)
    forall x Z:
        gcd(x, m) = 1
        then:
            cc(x, m) $in cc_prime_to(m)

"""
# EVEN HARDER: Implement after I implement the kernel to support fn_set, fn_to_fn, finite_seq, len
# EVEN HARDER: THE NUMBER OF ELEMENTS IN A FINITE SEQUENCE IS SORT OF HARD TO Define AND REASON IN LITEX, WHICH DOES NOT IMPLEMENT RECURSION DIRECTLY IN THE LANGUAGE.
# Theorem 6.2
# Let m, a, b be with m > 0, put d = gcd(a,m), then the congruence ax = b (mod m) has either exactly d solutions modulo m, or no solution; it has a solution iff b = 0 (mod d); there are exactly m/d distinct values of b modulo m for which this is so.

# Corollary 6.1
# The congruence classes prime to m modulo m make up a group under multiplication
fn set_of_integers_prime_to(m Z) set:
    forall x set_of_integers_prime_to(m):
        gcd(x, m) = 1

fn set_of_integers_prime_to_m_cc(m Z) set:
    forall x set_of_integers_prime_to(m):
        cc(m)(x) $in set_of_integers_prime_to_m_cc(m)

# Definition 6.2
# Definition of Euler's function; For any integer m > 0, the number of integers prime to m is denoted by phi(m)
"""

# Definition 6.3
# Definition of field
prop is_field(field set, add fn(field, field)field, mul fn(field, field)field, inv fn(field)field, add_e field, mul_e field, mul_inv fn(field)field):
    $is_commutative_ring(field, add, mul, inv, add_e, mul_e)
    forall a field, b field, c field:
        a != add_e
        b != add_e
        c != add_e
        then:
            mul(a, mul_inv(b)) = mul_e
            mul(b, mul_inv(a)) = mul_e

"""
# Theorem 6.3
# For any integer m > 1, the ring of congruence modulo m is a field
"""
