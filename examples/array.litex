Fn array(nat start, nat end, fn F, concept G, G g) Concept s:
  if nat n:: n >= start, n < end:
    s.has(F(n)(g))
  if var x: s.has(x):
    exist nat n:: F(n, g) = x
  
  s.size in Nat
  s.size <= end - start

  iff :: s.size = end - start :
    if nat n, nat m:: n >= start, n < end, m >= start, m < end, not m = n:
      not F(n)(g) = F(m)(g)

  G.contains(s)

  if :: G.size in Nat, end - start > G.size:
    exist nat n, nat m:: n >= start, n < end, m >= start, m < end, not m = n:
      F(n)(g) = F(m)(g)

  if :: G.size in Nat, end - start > G.size:
    exist var s1, var s2, nat n1, nat n2: s1 in s, s2 in s:
      s1 = s2


Concept Set s:

know if any G, any S:: G.contains(S), G.size in Nat:
  S.size in Nat
  S.size <= G.size

know:
  if nat start, nat end, fn F, concept G, G g, array(start, end, fn, concept) s::
    G.size in Nat, end - start > G.size
  :
    exist var s1, var s2, nat n1, nat n2: s1 in s, s2 in s, n1 < n2, n1 >= start, n1 < end, n2 >= start, n2 < end:
        s1 = s2
        s1 = F(n1)(g)
        s2 = F(n2)(g)