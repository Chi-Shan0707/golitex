Concept G Group:
  // define function
  fn *(x G, y G) G
  fn inv(x G) G

  // define one
  var 1 G

  // 注意到 var 1 G 等价于 fn 1(G Group) var; 然后后面出现的 G.1 都相当于变成 1(G) 就行
  // 这样的好处是，我比较两个 symbol的时候，可以容易弄很多，只要考虑 method，或者说fn，不用考虑 . property()

  // axioms
  if x G, y G:
    (x * y) * z = x * (y * z)
  if x G:
    x * G.1 = G.1 * x
  if x G:
    inv(x) * x = G.1
    x * inv(x) = G.1

Property Abelian[G Group]():
  if x G, y G:
    x * y = y * x

Set G Group
know $Abelian[G]()
if x G, y G:
  x * y = y * x

Concept AbelianGroup inherit Group G:
  G is Abelian

Concept M Monoid:
  fn *(x M,y M) M

  var 1 M;
  
  if x M, y M:
    (x * y) * z = x * (y * z)
  if x M:
    M.1 * x = x * M.1

Concept M Semigroup:
  fn *(x M,y M) M;

  if x M, y M:
      (x * y) * z = x * (y * z)

Property injective(F fn(x var) var):
  if x var, y var: F(x) = F(y):
      x = y

Property surjective(F fn(x var) var):
  if y var:: F.image.has(y):
    exist x var:
      F(x) = y

// 如何对 type 进行额外的要求？
Fn group_transformation[G Group](a G) F fn (x G) G:
  group_transformation[G](a)(x) = a * x

Claim:
  if [G Group] a G, F fn:: F = group_transformation[G](a):
    F is injective
prove:
  if x1 G, x2 G:: F(x1) = F(x2):
    // 对 F(x1) 进行实例化，用户必须自己做这一步，因为这里有“创造性”：用户用了F(x1) = F(x2)
    // 才知道 a * x1 = a * x2. 用到 F(x1) = a * x1，而不是别的什么东西，是有创造力的
    a * x1 = F(x1)
    a * x2 = F(x2)
    a * x1 = a * x2 // 实例化后才能知道这个对不对

    // 这一步必须用户自己写了：下面需要用这个做中间桥梁连起来x1,x2，而引入inv(a) 是有“创造性”的
    inv(a) * (a * x2) = inv(a) * (a * x1)
    inv(a) * (a * x2) = (inv(a) * a) * x2 = 1 * x2 = x2
    inv(a) * (a * x1) = (inv(a) * a) * x1 = 1 * x1 = x1
    x2 = x1
  
Claim:
  if [G Group] a G, b G:: a * b = G.1:
    b = inv(a)
prove:
  inv(a) * (a * b) = inv(a) * G.1
  inv(a) * (a * b) = (inv(a) * a) * b = G.1 * b = b
  inv(a) * G.1 = inv(a)
  b = inv(a)

Claim:
  if [G Group] a G, b G:
    inv(a * b) = inv(b) * inv(a)
prove:
  (a * b) * (inv(b) * inv(a)) = ((a * b) * inv(b)) * inv(a) = \
  (a * (b * inv(b))) * inv(a) = (a * G.1) * inv(a) = a * inv(a) = G.1
  inv(b) * inv(a) = inv(a * b)

Claim:
  if [G Group] :
    G::1 = inv(G::1)
prove:
  inv(G.1) * G.1 = G.1
  inv(G.1) * G.1 = inv(G.1)

/* Named Claim */
Property inverse_of_one_is_one(G Group):
  G.1 = inv(G.1)

Claim:
  if G Group:
    inverse_of_one_is_one(G)
prove:
  inv(G.1) * G.1 = G.1
  inv(G.1) * G.1 = inv(G.1)

import ("nat")

Fn ^(n Nat) F fn (x G) G:
  ^(++(n))(x) = ^(n)(x) * x
  ^(0)(x) = G.1

Fn power_of_inverse_is_inverse_of_power[G Group](x G) P Property (n Nat):
  ^(n)(inv(x)) = inv(^(n)(x))

Claim:
  if [G Group] x G, n Nat:
    power_of_inverse_is_inverse_of_power[G](x)(n)
prove:
  ^(0)(inv(x)) = G.1 = inv(G.1) = inv(^(0)(x))

  // 数学归纳法
  P(G,x)(0)
  if Nat n:: P(G,x)(n):
    ^(++(n))(x) = ^(n)(x) * x
    power_of_inverse_is_inverse_of_power(G, x)(n)
  if Nat n: 
    power_of_inverse_is_inverse_of_power(G, x)(n)
  // 自动检查 claim 里的东西是否正确

import ("set")

// 像定义函数那样定义属性
Property finite_order(G Group, a G):
  exist n Nat:
    ^(n)(a) = G.1

// ??? 这里需要内置一下 自然数和 set 了

/*

Claim:
  if G Group,a G:: G.size is Nat:
    finite_order(a)
prove:
  var Set s
  know if Nat n:: n > 0, n <= s.size + 1:
    s.has(^(n)(a))
  know s.size in Nat  // in 貌似要比 is 好，is用在属性，in用在类型
  if Nat n, m:: n > 0, n <= s.size + 1, m > 0, m <= s.size + 1, not ^(n)(a) = ^(m)(a):
    怎么说明 {a^1, ..., a^(n+1)} 如果里面的东西不一样，整个集合里面的元素的数量是n+1个？

*/

use_vars nat.Nat // 让 在 nat 里定义的 var，不需要写成 nat.XXX，可以直接调用，比如1,2

Claim:
  if G Group, g G:: G.size is Nat:
    finite_order(g)
prove:
  var set s:
    s = array(1, G.size + 2, ^, a)
  have s1 var, s2 var, 1, G.size + 1, ^, Nat, s:
    s1 = s2
    s1 = ^(n1)(g) // 此时 s1 绑定上性质 G，同时作为字面量等于 ^(n1)(g)
    s2 = ^(n2)(g)
  inv(^(n1)(g)) * ^(n1)(g) = inv(^(n1)(g)) * ^(n2)(g) // 我还没证明 右侧等于 ^(n2 - n1)(g)
  G.1 = ^(n2 - n1)(g)
  prove_exist:
    ^(n2 - n1)(g) = G.1
  finite_order(G, g)


var x G, y G:: x * y = y * x, x is R
have x, y :
  a G, b G :: a * b = b * a, a is R
exist a G, b G :: a * b = b * a, a is R

prove_is_concept 