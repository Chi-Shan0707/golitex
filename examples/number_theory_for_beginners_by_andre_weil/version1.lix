# Version 1: 2025-06-14

# This is first try to formalize the book. Because the kernel has implemented finite sequence, and it is relatively hard to define finite sequence in pure litex code (and more importantly, it is not necessary because soon I implement the kernel to support finite sequence), sometimes when it comes to definitions on "a finite sequence of numbers", I suppose the finite sequence has exactly 2 elements. For example, mutually prime sequence is defined as a finite sequence of numbers, and each number is a prime number, and the two numbers are mutually prime. In my case, I just define a finite sequence as a pair of numbers.

# Since this is version 1, I do not prove anything. I just formalize all the propositions and definitions and "know" they are true.

"""
Basics
"""

forall x R, a R, b R:
    a + x = b
    then:
        a + x - a = b - a
        x = b - a

forall x R, a R, b R:
    a != 0
    a * x = b
    then:
        a * x / a = b / a
        x = b / a

know:
    forall a R, b R:
        b  >  a
        then:
            b - a > 0

    forall a R, b R:
        b > a
        then:
            b >= a 
            b != a

    forall a R, b R:
        b < a
        then:
            a > b

exist_prop x Z st is_divisible_by(b Z, a Z):
    a * x = b

prop is_smallest_element_of(x N, s set):
    dom:
        forall y s:
            y $in Z
        x $in s
    iff:
        forall y s:
            y >= x

exist_prop x obj st non_empty(s set):
    x $in s

know exist_prop x N st exist_smallest_element_of(s set):
    dom:
        $non_empty(s)
        forall y s:
            y $in Z
    iff:
        x $in s
        $is_smallest_element_of(x, s)
    

"""
Chapter 1
"""

# Handy builtin rules are there for verifying basic properties of real numbers.
prove:
    obj x R, y R, z R
    (x + y) + z = x + (y + z)
    x + y = y + x
    0 + x = x
    (x*y)*z = x*(y*z)
    x*y = y*x
    1*x = x
    x*(y+z) = x*y + x*z

know:
    forall a Z, b Z:
        a - b $in Z
        a + b $in Z
        a * b $in Z

    forall a Q, b Q:
        a - b $in Q
        a + b $in Q
        a * b $in Q

    forall a Q, b Q:
        a != 0
        then:
            b / a $in Q

"""
Chapter 2
"""

# Lemma 2.1

# TODO: THIS CLAIM CAN BE PROVED
know exist_prop q Z st exist_largest_multiple_of(d Z, a Z):
    iff:
        a >= d * q
        d*(q+1) > a

# Theorem 2.1

# TODO: THIS CLAIM CAN BE PROVED
know exist_prop m N st nonempty_set_of_integers_closed_under_addition_has_elements_divisible_by_a_common_divisor(s set):
    dom:
        $non_empty(s)
        forall x s:
            x $in Z
    iff:
        forall x s:
            x $in Z
            $is_divisible_by(m, x)

# Corollary 2.1
# Specialized case

# Define integral linear combination of two integers

exist_prop c Z, d Z st is_linear_combination_of_two_integers(x Z, a Z, b Z):
    x = c * a + d * b

## 可能可以给用户一个语法糖，让他们能更轻松地让下面这两个定义合并

fn set_of_integer_linear_combination_of_two_integers(a Z, b Z) set:
    forall x set_of_integer_linear_combination_of_two_integers(a, b):
        x $in Z
        $is_linear_combination_of_two_integers(x, a, b)

know:
    forall x Z, a Z, b Z:
        $is_linear_combination_of_two_integers(x, a, b)
        then:
            x $in set_of_integer_linear_combination_of_two_integers(a, b)

fn set_of_multiples_of(d N) set:
    forall x set_of_multiples_of(d):
        x $in Z
        x $is_divisible_by d

know:
    forall x Z, d N:
        x $is_divisible_by d
        then:
            x $in set_of_multiples_of(d)

know:
    forall x Z, d N:
        x $in set_of_multiples_of(d)
        then:
            x $is_divisible_by d

# Corollary itself

# 存在唯一性所以用fn
# 事实上这就是gcd的定义
# Definition 1 at page 7
fn gcd(a Z, b Z) N:
    set_of_multiples_of(gcd(a, b)) = set_of_integer_linear_combination_of_two_integers(a, b)
    
# Corollary 2.2
# Specialized case

know forall a Z, b Z, d Z:
    d != 0
    a $is_divisible_by d
    b $is_divisible_by d
    then:
        gcd(a, b) $is_divisible_by d

"""
Chapter 3
"""

# Definition 3.1
prop relatively_prime(a Z, b Z):
    gcd(a, b) = 1

exist_prop c Z, d Z st exist_relatively_prime(a Z, b Z):
    a * c + b * d = 1

# Theorem 3.1
know forall a Z, b Z:
    gcd(a, b) = 1
    iff:
        $exist_relatively_prime(a, b)

# Corollary 3.1
know forall a Z, b Z:
    dom:
        a != 0
        b != 0
    then:
        a / gcd(a, b) $in Z
        b / gcd(a, b) $in Z
        gcd(a / gcd(a, b), b / gcd(a, b)) = 1

# facts that are not mentioned but still used
know forall a Z, b Z, d Z:
    a $is_divisible_by d
    b $is_divisible_by d
    then:
        a + b $is_divisible_by d
        a - b $is_divisible_by d
        a * b $is_divisible_by d

# Theorem 3.2
know forall a Z, b Z, d Z:
    gcd(a, d) = 1
    a*b $is_divisible_by d
    then:
        b $is_divisible_by d

# Corollary 3.1
know forall a Z, b Z, d Z:
    gcd(a, b) = 1
    gcd(a, d) = 1
    then:
        gcd(a, b*d) = 1

"""
Chapter 4
"""

# Definition 4.1
prop is_prime(p Z):
    p > 1
    forall x Z:
        dom:
            x > 1
            p $is_divisible_by x
        then:
            x = p

# Theorem 4.1
know prop a_prime_divides_a_product_of_two_integers_if_it_divides_one_of_the_factors(p Z, a Z, b Z):
    p $is_prime
    p $is_divisible_by a * b
    then:
        or:
            p $is_divisible_by a
            p $is_divisible_by b

# Theorem 4.2
# Every integer > 1 is a product of primes
# TODO: This can be formalized after I implement the kernel to support finite sequence
"""
know exist_prop seq finite_seq st exist_primes_whose_equal_to_integer(a Z):
    a > 1
    iff:
        forall x seq:
            x $is_prime
            a $is_divisible_by x
        a = product_of_finite_seq(seq)
"""

# Theorem 4.3
know exist_prop p Z st exist_prime_greater_than_any_integer(x Z):
    p > x
    p $is_prime

"""
Chapter 5
"""


# Definition 5.1

# TODO: 这得在with-suppose正常工作的时候才能奏效
prop is_commutative_group(G set, op fn(G, G)G, inv fn(G)G, e G):
    forall a G, b G:
        op(a, b) = op(b, a)

    forall a G:
        op(a, e) = a
        op(e, a) = a
        op(a, inv(a)) = e
        op(inv(a), a) = e

    forall a G, b G, c G:
        op(a, op(b, c)) = op(op(a, b), c)

# Definition 5.2

prop is_congruent_modulo(a Z, b Z, n Z):
    dom:
        n != 0
    then:
        a - b $is_divisible_by n

prop congruent_modulo_is_transitive(a Z, b Z, c Z, n Z):
    $is_congruent_modulo(a, b, n)
    $is_congruent_modulo(b, c, n)
    then:
        $is_congruent_modulo(a, c, n)

know:
    # Reflexive
    forall x Z, m Z:
    	$is_congruent_modulo(x, x, m)

    # Transitive
    forall x Z, y Z, z Z, m Z:
    	$congruent_modulo_is_transitive(x, y, z, m)

    # Symmetric
    forall x Z, y Z, m Z:
    	$is_congruent_modulo(x, y, m)
        then:
        	$is_congruent_modulo(y, x, m)

    forall x Z, y Z, x2 Z, y2 Z, m Z:
    	$is_congruent_modulo(x, y, m)
        $is_congruent_modulo(x2, y2, m)
        then:
            $is_congruent_modulo(x + x2, y + y2, m)
            $is_congruent_modulo(x - x2, y - y2, m)
            $is_congruent_modulo(x * x2, y * y2, m)

    forall x Z, y Z, m Z, d Z:
        dom:
            d != 0
            x $is_divisible_by d
            y $is_divisible_by d
            m $is_divisible_by d
        then:
        	$is_congruent_modulo(x, y, m)
        iff:
            $is_congruent_modulo(x / d, y / d, m / d)

# Definition 5.3
# ERROR: cc 不是函数，而是集合
fn cc(d Z, m Z) set:
    dom:
        m != 0
    iff:
        forall x cc(d, m):
            $is_congruent_modulo(x, d, m)



# Theorem 5.1
# TODO: THIS IS HARD TO FORMALIZE FOR THE TIME BEING BECAUSE THE MOD OPERATOR IS ACTUALLY NOT A FUNCTION. IT IS A SET OF FUNCTIONS8
"""
# cc is short form of congruent class
fn_set cc(m Z):
    m > 0
    iff:
        fn f(d Z) set:
            forall x Z:
                $is_congruent_modulo(x, d, m)
                then:
                    x $in f(d)

fn_to_fn cc_add(m Z):
    m > 0
    iff:
        fn f(d cc(m), e cc(m)) cc(m):
            cc(m)(d +  e) = cc_add(m)(cc(m)(d), cc(m)(e))
"""

"""
Chapter 6
"""

# Definition 6.1
# TODO: THIS ONLY WORKS WHEN suppose-when is implemented
# Definition of ring
prop is_unary_ring(ring set, add fn(ring, ring)ring, mul fn(ring, ring)ring, inv fn(ring)ring, add_e ring, mul_e ring):
    $is_commutative_group(ring, add, inv, add_e)
    forall a ring, b ring, c ring:
        add(mul(a, b), mul(a, c)) = mul(a, add(b, c))
        mul(a, mul(b, c)) = mul(mul(a, b), c)
        mul(a, b) = mul(b, a)
    forall a ring:
        mul(a, mul_e) = a
        mul(mul_e, a) = a

"""
# Implement after I implement the kernel to support fn_set, fn_to_fn
# Theorem 6.1
fn_to_fn cc_mul(m Z):
    m > 0
    iff:
        fn f(d cc(m), e cc(m)) cc(m):
            cc(m)(d * e) = cc_mul(m)(cc(m)(d), cc(m)(e))

know prop cc_is_unitary_ring(m Z):
    $is_unary_ring(cc(m), cc_add(m), cc_mul(m), cc(m)(0), cc(m)(1))
"""

"""
# EVEN HARDER: Implement after I implement the kernel to support fn_set, fn_to_fn, finite_seq, len
# EVEN HARDER: THE NUMBER OF ELEMENTS IN A FINITE SEQUENCE IS SORT OF HARD TO Define AND REASON IN LITEX, WHICH DOES NOT IMPLEMENT RECURSION DIRECTLY IN THE LANGUAGE.
# Theorem 6.2
# Let m, a, b be with m > 0, put d = gcd(a,m), then the congruence ax = b (mod m) has either exactly d solutions modulo m, or no solution; it has a solution iff b = 0 (mod d); there are exactly m/d distinct values of b modulo m for which this is so.

# Corollary 6.1
# The congruence classes prime to m modulo m make up a group under multiplication
fn set_of_integers_prime_to(m Z) set:
    forall x set_of_integers_prime_to(m):
        gcd(x, m) = 1

fn set_of_integers_prime_to_m_cc(m Z) set:
    forall x set_of_integers_prime_to(m):
        cc(m)(x) $in set_of_integers_prime_to_m_cc(m)

# Definition 6.2
# Definition of Euler's function; For any integer m > 0, the number of integers prime to m is denoted by phi(m)
"""

# Definition 6.3
# Definition of field
prop is_field(field set, add fn(field, field)field, mul fn(field, field)field, inv fn(field)field, add_e field, mul_e field, mul_inv fn(field)field):
    $is_commutative_ring(field, add, mul, inv, add_e, mul_e)
    forall a field, b field, c field:
        a != add_e
        b != add_e
        c != add_e
        then:
            mul(a, mul_inv(b)) = mul_e
            mul(b, mul_inv(a)) = mul_e

"""
# Theorem 6.3
# For any integer m > 1, the ring of congruence modulo m is a field
"""

"""
Chapter 7
"""

# 缺：判断一个函数在某函数集合里

"""
fn_fn two_items_op_on_subset(s set, op fn(s, s)s, items set):
    fn (x items, y items) s:
        op(x, y) = op_on_subset(s, op, items)(x, y)
    dom:
        items $subset_of s
        forall x items, y items:
            op(x, y) $in s

fn_fn one_item_op_on_subset(s set, op fn(s, s)s, items set):
    fn (x items) s:
        op(x, x) = op_on_subset(s, op, items)(x, x)
    dom:
        items $subset_of s
        forall x items:
            op(x) $in s

prop two_items_op_return_value_in_set(s set, f_original_ret_set set, f fn(s, s)f_original_ret_set, return_value_set set):
    forall x s, y s:
        f(x, y) $in return_value_set

prop one_item_op_return_value_in_set(s set, f_original_ret_set set, f fn(s)f_original_ret_set, return_value_set set):
    forall x s:
        f(x) $in return_value_set

# 或许应该是要能自动lift？而不是定义lift函数？比如虽然f $in fn(s,s)s 但是如果在items，items上它满足了返回值也是items，那我们也应该认为它是 $in fn(items, items) items ???? 还是说这里的 in 用的不好，而是应该用其他的 特殊的关键词来说明整个事情？或者说我有个新的prop叫can be restricted on 

# Definition 7.1
fn group_generated_by_items(s set, op fn(s, s)s, e s, inv fn(s)s, items set) set:
    $is_group(s, op, e, inv)
    items $subset_of s

    then:
        e $in group_generated_by_items(s,op,e,inv,items)

        $one_item_op_return_value_in_set(s, s, one_item_op_on_subset(s, s, op, group_generated_by_items(s,op,e,inv,items)), group_generated_by_items(s,op,e,inv,items))
        $two_items_op_return_value_in_set(s, s, two_items_op_on_subset(s, s, op, group_generated_by_items(s,op,e,inv,items)), group_generated_by_items(s,op,e,inv,items))
        
        $is_group(group_generated_by_items(s,op,e,inv, items), two_items_op_on_subset(s, op, group_generated_by_items(s,op,e,inv,items)), e, one_item_op_on_subset(s, op, group_generated_by_items(s,op,e,inv,items)))

        forall x items:
            x $in s
            then:
                x $in group_generated_by_items(s, op, e, inv, group_generated_by_items(s,op,e,inv,items))

        forall s set:
            items $subset_of s
            then:
                group_generated_by_items(s, op, e, inv, items) $subset_of s

fn mul_on_group(s set, op fn(s, s)s, e s, inv fn(s)s, n N)s :
    $is_group(s, op, e, inv)
    then:
        mul_on_group(s, op, e, inv, 0) = e
        forall n N:
            mul_on_group(s, op, e, inv, n + 1) = mul_on_group(s, op, e, inv, n) + 1

# Definition 7.2
# Isomorphism of groups

prop is_isomorphism_of_groups(s1 set, op1 fn(s1, s1)s1, e1 s1, inv1 fn(s1)s1, s2 set, op2 fn(s2, s2)s2, e2 s2, inv2 fn(s2)s2, iso_map fn(s1)s2):
    $is_group(s1, op1, e1, inv1)
    $is_group(s2, op2, e2, inv2)
    $is_bijection(iso_map)
    then:
        forall x s1, y s1:
            iso_map(op1(x, y)) = op2(iso_map(x), iso_map(y))
            iso_map(inv1(x)) = inv2(iso_map(x))
            iso_map(e1) = e2

# Theorem 7.2 ?

# Definition 7.3
# Definition of cyclic group

fn 1_element_set(s obj) set:
    forall x 1_element_set(s):
        x = s
    s $in 1_element_set(s)

prop is_cyclic_group(s set, op fn(s, s)s, e s, inv fn(s)s, generator s):
    $is_group(s, op, e, inv)
    forall x s:
        s = group_generated_by_items(s, op, e, inv, 1_element_set(s))

# Definition 7.4
# Definition of order of an element

# TODO: 需要定义n次幂生成出来的元素构成的集合

prop is_order_of_element(s set, op fn(s, s)s, e s, inv fn(s)s, element s, order N):
    $is_cyclic_group(s, op, e, inv, element)
    $is_finite_set(s)

"""

