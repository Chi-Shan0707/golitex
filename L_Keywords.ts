export const specialChars = [
  "(",
  ")",
  "{",
  "}",
  "[",
  "]",
  ":",
  ",",
  ";",
  "&",
  "|",
  "\\",
  "=",
  "$",
  '"', // for regex parser
];

export const L_Keywords = {
  DollarKeyword: "$",
  SlashKeyword: "\\",
  EqualKeyword: "=",
  LetCompositeKeyword: "def_composite",
  isPropertyKeyword: "is_property",
  isFormKeyword: "is_form",
  KnowTypeKeywords: "know",
  ThenKeyword: "=>",
  IffKeyword: "iff",
  IfKeyword: "if",
  DefKeywords: "def",
  ProveKeywords: "prove",
  L_End: ";",
  LetKeyword: "let",
  HaveKeywords: "have",
  ProveByContradictionKeyword: "prove_by_contradiction",
  IsKeywords: "is",
  NotKeywords: "not",
  OrKeyword: "or",
  AndKeyword: "and",
  ClearKeyword: "clear",
  RunKeyword: "run",
  MacroKeywords: "macro",
  LeftBrace: "(",
  RightBrace: ")",
  specialCharsOpen: "{",
  specialCharsCloseBracket: "}",
  specialCharsSquareOpen: "[",
  specialCharsSquareClose: "]",
  specialCharsColon: ":",
  specialCharsComma: ",",
  specialCharsSemicolon: ";",
  specialCharsAmpersand: "&",
  specialCharsPipe: "|",
  specialCharsBackslash: "\\",
  specialCharsEqual: "=",
  specialCharsDollar: "$",
  lets: "lets",
  macro: "macro",
  include: "include",
  commutative: "commutative",
  def_literal_operator: "def_literal_operator",
  ifVarPrefix: "%if_",
  literalOptPrefix: "@",
  macroPrefix: "MACRO_",
  def_exist: "def_exist",
  indexedSymbolKeyword: "at",
  // TODO anonymous and any can not appear in some composites, so in the future I should make them stricter.
  anonymousSymbol: "?",
  anySymbol: "ANY", //* anySymbol can not be equal to anonymous, and it can equal to any other symbols
};
