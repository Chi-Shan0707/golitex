Concept Group G:
  // define function
  fn *(G x, G y) G
  fn inv(G x) G

  // define one
  var G 1

  // axioms
  if G x, G y:
    (x * y) * z = x * (y * z)
  if G x:
    x * G.1 = G.1 * x
  if G x:
    inv(x) * x = G.1
    x * inv(x) = G.1

Property Abelian of Group G:
  if G x, G y:
    x * y = y * x

Concept AbelianGroup of Group G:
  G is Abelian

Concept Monoid M:
  fn *(M x, M y) M;

  var M 1;
  
  if M x, M y:
    (x * y) * z = x * (y * z)
  if M x:
    M.1 * x = x * M.1

Concept Semigroup S:
  fn *(M x, M y) M;

  if M x, M y:
      (x * y) * z = x * (y * z)

Property injective of fn F(any x):
  if any x, any y: F(x) = F(y):
    x = y

Property surjective of fn F(any x):
  if any y :: F.image.has(y):
    exist any x:
      F(x) = y

Fn group_transformation(Group G, G a) fn F(G x) G:
  group_transformation(G, a)(x) = a * x

Claim:
  if Group G, G a, fn group_transformation(G, a)(G x) F:
    F is injective
prove:
  if G x1, G x2:: F(x1) = F(x2):
    // 对 F(x1) 进行实例化，用户必须自己做这一步，因为这里有“创造性”：用户用了F(x1) = F(x2)
    // 才知道 a * x1 = a * x2. 用到 F(x1) = a * x1，而不是别的什么东西，是有创造力的
    a * x1 = F(x1)
    a * x2 = F(x2)
    a * x1 = a * x2 // 实例化后才能知道这个对不对

    // 这一步必须用户自己写了：下面需要用这个做中间桥梁连起来x1,x2，而引入inv(a) 是有“创造性”的
    inv(a) * (a * x2) = inv(a) * (a * x1)
    inv(a) * (a * x2) = (inv(a) * a) * x2 = 1 * x2 = x2
    inv(a) * (a * x1) = (inv(a) * a) * x1 = 1 * x1 = x1
    x2 = x1
  
Claim:
  if Group G, G a, G b:: a * b = G.1:
    b = inv(a)
prove:
  inv(a) * (a * b) = inv(a) * G.1
  inv(a) * (a * b) = (inv(a) * a) * b = G.1 * b = b
  inv(a) * G.1 = inv(a)
  b = inv(a)

Claim:
  if Group G, G a, G b:
    inv(a * b) = inv(b) * inv(a)
prove:
  (a * b) * (inv(b) * inv(a)) = ((a * b) * inv(b)) * inv(a) = \
  (a * (b * inv(b))) * inv(a) = (a * G.1) * inv(a) = a * inv(a) = G.1
  inv(b) * inv(a) = inv(a * b)

Claim:
  if Group G:
    G.1 = inv(G.1)
prove:
  inv(G.1) * G.1 = G.1
  inv(G.1) * G.1 = inv(G.1)

/* Named Claim */
Property inverse_of_one_is_one(Group G):
  G.1 = inv(G.1)

Claim:
  if Group G:
    inverse_of_one_is_one(G)
prove:
  inv(G.1) * G.1 = G.1
  inv(G.1) * G.1 = inv(G.1)

import ("nat")

Fn ^(Nat n) fn F(G x) G:
  ^(++(n))(x) = ^(n)(x) * x
  ^(0)(x) = G.1

Fn power_of_inverse_is_inverse_of_power(Group G, G x) Property P(Nat n):
  ^(n)(inv(x)) = inv(^(n)(x))

Claim:
  if Group G, G x, Nat n:
    power_of_inverse_is_inverse_of_power(G, x)(n)
prove:
  ^(0)(inv(x)) = G.1 = inv(G.1) = inv(^(0)(x))

  // 数学归纳法
  P(G,x)(0)
  if Nat n:: P(G,x)(n):
    ^(++(n))(x) = ^(n)(x) * x
    power_of_inverse_is_inverse_of_power(G, x)(n)
  if Nat n: 
    power_of_inverse_is_inverse_of_power(G, x)(n)
  // 自动检查 claim 里的东西是否正确

import ("set")

// 像定义函数那样定义属性
Property finite_order(G a):
  G is Group
  exist Nat n:
    ^(n)(a) = G.1

Claim:
  if Group G, G a:: G.size is Nat:
    finite_order(a)
prove:
  var Set s
  know if Nat n:: n > 0, n <= s.size + 1:
    s.has(^(n)(a))
  know s.size in Nat  // in 貌似要比 is 好，is用在属性，in用在类型
  if Nat n, m:: n > 0, n <= s.size + 1, m > 0, m <= s.size + 1, not ^(n)(a) = ^(m)(a):
    

