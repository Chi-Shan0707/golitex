pub concept group(G) {
  exist {
    fn *(x G, y G) G,
    fn inv(x G) G,
    var 1 G,
  }

  ctr {
    if x G, y G {
      (x * y) * z = x * (y * z)
    },
    if x G {
      x * G.1 = G.1 * x
    },
    if x G {
      inv(x) * x = G.1;
      x * inv(x) = G.1;
    }
  }
}

ctr Abelian(G Group) {
  if x G, y G {
    x * y = y * x
  }
}

 {
  pri set_var G Group ;
  know $Abelian(G);
  if x G, y G {
    x * y = y * x
  };
 }


var_trait injective(F fn(x var) var) {
  if x var, y var: F(x) = F(y) {
      x = y
  }
}

Claim {
  if [G Group] a G, F fn:: F = group_transformation[G](a) {
    F is injective
  }
} prove {
  if x1 G, x2 G:: F(x1) = F(x2) {
    a * x1 = F(x1);
    a * x2 = F(x2);
    a * x1 = a * x2; 
    inv(a) * (a * x2) = inv(a) * (a * x1);
    inv(a) * (a * x2) = (inv(a) * a) * x2 = 1 * x2 = x2;
    inv(a) * (a * x1) = (inv(a) * a) * x1 = 1 * x1 = x1;
    x2 = x1;
  }
}

import ("nat")

Fn ^(n Nat) F fn (x G) G {
  ^(++(n))(x) = ^(n)(x) * x;
  ^(0)(x) = G.1;
}

Fn power_of_inverse_is_inverse_of_power[G Group](x G) P Property (n Nat) {
  ^(n)(inv(x)) = inv(^(n)(x))
}