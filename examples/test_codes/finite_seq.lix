"""
# 本质上这里有问题。因为finite_seq根本不是set，而是一个函数

prop is_finite_seq(s set)
fn len(seq set) N:
    dom:
        $is_finite_seq(seq)

fn at(seq set, i N) seq:
    dom:
        $is_finite_seq(seq)
        i < len(seq)

obj seq1 set:
    seq1 $is_finite_seq
    len(seq1) = 2
    0 < 2 # bug : 为啥不能直接验证出来 0 < len(seq1)
    1 < 2
    seq1 \at 0 = 1
    seq1 \at 1 = 2

seq1 \at 0 $in seq1
seq1 \at 1 $in seq1

know exist_prop i N st any_item_seq_has_index(seq set, i N):
    dom:
        seq $is_finite_seq
        i < len(seq)
    iff:
        seq \at i = a

"""

prop is_finite_seq(f seq)

# 定义了一个函数集合，这个函数的运算规则是读入一个N，然后返回一个obj
fn_set seq(x N) obj

fn seq_len(f seq) N:
    dom:
        $is_finite_seq(f)

obj f seq:
    $is_finite_seq(f)
    seq_len(f) = 2

set_set congruence_class

# 符合让 fn_set 返回 fn_set。比如 fn_set1(x N) 返回 fn_set2(x N)
fn_set fn_set1(x N) fn_set2
fn_set fn_set2(x N) obj

# set_of_sets: 
obj set_of_sets1 set:
    forall x set_of_sets1:
        x $in set_of_sets2

obj set_of_sets2 set:
    forall x set_of_sets2:
        x $in set

fn congruence_class(n N) set_of_sets1 
know exist_prop m N st everything_in_set_of_sets1_is_congruent_to_m(x set_of_sets1):
    everything_in_set_of_sets1_is_congruent_to_m(x) = congruence_class(m)

fn congruence_class_elem(n N, m N) set_of_sets2