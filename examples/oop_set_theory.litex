concept object {}
concept set {
  relation has(x) {}
  
  static relation =(x, y): x is set, y is set {
   iff =(x,y) <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)};
   /* iff this <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)}; */
  }

  /*
  static relation =(x, y): all x,y are set {
    if x,y: all x,y are set {iff =(x,y) <=> if z: x.has(z) {y.has(z)}, if z: y.has(z) {x.has(z)} };
  }
  */

  static var empty_set {
    know empty_set is set;
    if x: {not x empty_set.has(x)};
  }
}

fn static set::singleton(a)  => var {
  this is set;
  if z: this.has(z) {a = z};
  this.has(a);
}

fn static set::pair(a,b) => var {
  this is set;
  this.has(a,b);
  if z: this.has(z) {
    z = b or z = a
  };
}

fn static set::union(a, b: all a,b are set) => var {
  this is set;
  if z: this.has(z) {
    a.has(z) or b.has(z)
  }
}

relation static set::subset(a, b: all a,b are set)  {
  know if z: a.has(z) {b.has(z)}
}

fn static set::specification(A, relation P(x: A.has(x)): A is set, ) => concept {
  know exist this;
}

fn static set::intersection(a,b: all a,b are set) => var {
  iff z: this.has(z) <=> {a.has(z), b.has(z)}
}

// ?
fn static fn set::replacement(A, relation P(x,y: A.has(x)): A is set, 
if z,y1,y2: A.has(z), if : P(z,y1), P(z,y2) {y1 = y2}) => concept {
  if S: S is this {S is set, iff z: S.has(z) {exist x: A.has(x) P(x,z)} }
}

know if A: A is set, A != set::empty_set {
  exist x: not x is set or set::intersection(x,A) = set::empty_set;
}