# Litex 代码示例：希尔伯特几何公理系统

# 希尔伯特的公理系统由六种基本符号组成。其中，有三种基本对象：点、直线（简称“线”）、平面（简称“面”）；以及三种基本关系：

# 夹（betweenness）：一种联系点的三元关系；
# 落（lies on）/含（containment）：一组三种二元关系，分别联系点与直线、点与平面，以及平面与直线；
# 同（congruence）：一组两种二元关系，分别联系两条线段或两个角，均以中缀符号 ≅ 表示。
# 上面提到的线段、角，以及更多诸如三角形之类的概念，均可在点线面的基本对象上，运用夹与含这两种基本关系加以定义。下面所列出的公理中，除非特别声明，所有提及的对象都是互异的。

set point
set line
set plane

prop point_on_line(p point, l line)
prop point_on_plane(q point, p plane)
prop line_on_plane(l line, p plane)

# 1. 所在型定理

# 1. 给定任意两点 A、B，存在一条直线 a 同时包含其二者。这记作 AB=a 或 BA=a。 除了“a 包含 A 与 B”，也可以用其他方式表述，例如：“A 是 a 上的点”“a 穿过了 A 与 B”“a 连接了 A 与 B”。 若点 A 同时落于两条直线 a 与 b 上，也可以说“直线 a 与 b 有公共点 A”。

fn line_of(a point, b point) line:
    a != b
    then:
        $point_on_line(line_of(a, b), a)
        $point_on_line(line_of(a, b), b)
        forall l line:
            $point_on_line(a, l)
            $point_on_line(b, l)
            then:
                l = line_of(a, b)

prove:
    obj a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
    l = line_of(a, b)


# Tips: prove 表示开一个局部环境，下面的所有内容不会对大环境有影响，用途是让用户做一些小测试

# 2. 给定任意两点 A、B，最多只存在一条直线同时包含其二者。这也是说，若对于相异两点 B、C，同时有 AB=a 与 AC=a，那么有 BC=a。

know forall l line, a point, b point:
    a != b
    $point_on_line(a, l)
    $point_on_line(b, l)
    then:
        $a_line_has_more_than_two_points(l, a, b)

# 3.1 一条直线上至少存在两个点

exist_prop c point st a_line_has_more_than_two_points(l line, a point, b point):
    a != b
    $point_on_line(a, l)
    $point_on_line(b, l)
    iff:
        $point_on_line(c, l)
        c != a
        c != b

know forall l line, a point, b point:
    a != b
    $point_on_line(a, l)
    $point_on_line(b, l)
    then:
        $a_line_has_more_than_two_points(l, a, b)

prove:
    obj a point, b point, l line:
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)

    $a_line_has_more_than_two_points(l,a,b)

    have c st $a_line_has_more_than_two_points(l,a,b)

    $point_on_line(c,l)

# 3.2 至少存在不共线的三个点

exist_prop c point st exist_one_point_not_on_the_same_line_with_two_points(a point, b point):
    a != b
    iff:
        not $point_on_line(c, line_of(a, b))

know forall a point, b point:
    a != b
    then:
        $exist_one_point_not_on_the_same_line_with_two_points(a, b)

prove:
    obj a point, b point:
        a != b
    $exist_one_point_not_on_the_same_line_with_two_points(a, b)
    have c st $exist_one_point_not_on_the_same_line_with_two_points(a, b)

# Tip: 用户有义务让代码更易读，以便在社区中分享并让自己更好管理项目。最好的方式就是取名取的合适到位。长一些的命名是有益的，这样能用名字就说清楚所有的信息，也更符合人们阅读自然语言的习惯。用户不必担心打字太多，因为大部分的IDE在你输入名字的头几位时，就会提示或补全剩下的名字。

# 4. 对于任意不共线三点 A、B、C，存在一同时包含其三者的平面 α。这记作 ABC=α。 亦可说是“A、B、C 落于 α 上”“A、B、C 是 α 上的点”。

# 5. 对于任意不共线三点 A、B、C，最多只存在一个平面同时包含其三者。

fn plain_of(a point, b point, c point) plane:
    a != b
    a != c
    b != c
    then:
        $point_on_plane(a, plain_of(a, b, c))
        $point_on_plane(b, plain_of(a, b, c))
        $point_on_plane(c, plain_of(a, b, c))
        forall p plane:
            $point_on_plane(a, p)
            $point_on_plane(b, p)
            $point_on_plane(c, p)
            then:
                p = plain_of(a, b, c)

# Tip: 存在唯一用fn（函数）表示

# 6. 若在直线 a 上的两点 A、B 同时落于平面 α 上，那么 a 上的任意点均落于 α 上。又说“直线 a 落于平面 α 上”。

know:
    forall p plane, a point, b point:
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        a != b
        then:
            $point_on_line(p, line_of(a, b))

know prop two_points_on_line_then_line_on_plane(a point, b point, l line, p plane):
        a != b
        $point_on_line(a, l)
        $point_on_line(b, l)
        then:
            $line_on_plane(l, p)

prove:
    obj a point, b point, p plane:
        $point_on_plane(a, p)
        $point_on_plane(b, p)
        a != b
    $point_on_line(p, line_of(a, b))

# 7. 若平面 α、β 均包含点 A，那么它们至少共同包含另一点 B。

exist_prop b point st two_planes_have_one_common_point_then_they_have_another_common_point(a point, p plane, q plane):
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    iff:
        $point_on_plane(b, p)

know forall a point, p plane, q plane:
    $point_on_plane(a, p)
    $point_on_plane(a, q)
    then:
        $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)

prove:
    obj a point, p plane, q plane:
        $point_on_plane(a, p)
        $point_on_plane(a, q)
    $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    have b st $two_planes_have_one_common_point_then_they_have_another_common_point(a, p, q)
    $point_on_plane(b, p)

# 8. 至少存在不共面的四个点。

exist_prop a point, b point, c point, d point st exist_four_points_not_on_any_plane():
    a != b
    a != c
    a != d
    b != c
    b != d
    c != d
    $not_on_any_plane(a, b, c, d)

know $exist_four_points_not_on_any_plane()

prop not_on_any_plane(a point, b point, c point, d point):
    forall p plane:
        or:
            not $point_on_plane(a, p)
            not $point_on_plane(b, p)
            not $point_on_plane(c, p)
            not $point_on_plane(d, p)

prove:
    have a , b , c , d  st $exist_four_points_not_on_any_plane()
    $not_on_any_plane(a, b, c, d)

    forall p plane:
            or:
                not $point_on_plane(a, p)
                not $point_on_plane(b, p)
                not $point_on_plane(c, p)
                not $point_on_plane(d, p)

# 2. 顺序型定理

# 1. 对于互异三点 A、B、C，若 B 夹在 A、C 间，则 B 亦夹在 C、A 间，且存在一条直线同时包含 A、B、C。

prop between(left point, right point, middle point):
    dom:
        left != right

exist_prop l line st exist_line_through_three_points(a point, b point, c point):
    a != b
    a != c
    b != c
    iff:
        $point_on_line(a, l)
        $point_on_line(b, l)
        $point_on_line(c, l)

know forall left point, right point, middle point:
    left != right
    $between(left, right, middle)
    then:
        $between(right, left, middle)
        $exist_line_through_three_points(left, right, middle)

prove:
    obj left point, right point, middle point:
        left != right
        $between(left, right, middle)

    $between(right, left, middle)
    $exist_line_through_three_points(left, right, middle)

    have l st $exist_line_through_three_points(left, right, middle)
    $point_on_line(left, l)
    $point_on_line(right, l)
    $point_on_line(middle, l)

# tip: 如果一个prop里面的参数数量是2，那不只可以写成 $propName(a,b) 还能写成 a $propName b
# tip: 如果一个fn里面的参数数量是2，那不只可以写成 fn(a,b) 还能写成 a \fn b

# 2. 对于互异两点 A、C，至少存在一点 B 落于直线 AC 上，使得 C 夹在 A、B 之间。

exist_prop right point st exist_point_right_to_given_two_points(left point, middle point):
    left != middle
    iff:
        $between(left, right, middle)

know forall a point, b point:
    a != b
    then:
        $exist_point_right_to_given_two_points(a, b)

prove:
    obj a point, b point:
        a != b

    $exist_point_right_to_given_two_points(a, b)

    have right  st $exist_point_right_to_given_two_points(a, b)

    $between(a, right, b)

# 3. 直线上的任意三点最多只能有一个夹在其余两者之间。

know prop no_more_than_one_point_between_three_points_on_line(a point, b point, c point):
    a != b
    a != c
    b != c
    iff:
        or:
            $between(a, b, c)
            $between(a, c, b)
            $between(b, a, c)
            $between(b, c, a)
            $between(c, a, b)
            $between(c, b, a)

prove:
    obj a point, b point, c point:
        a != b
        a != c
        b != c

    $no_more_than_one_point_between_three_points_on_line(a, b, c)

    know:
        not $between(a, b, c)
        not $between(a, c, b)
        not $between(b, a, c)
        not $between(b, c, a)
        not $between(c, a, b)
    
    $between(c, b, a)


# tip: know prop 是语法糖：同时定义了prop，并让所有满足prop的参数都满足prop

# 4. 给定三点 A、B、C 与平面 ABC 上不穿过三点中任意一个的直线 α，若 α 穿过线段 AB，则其必然同时穿过线段 AC 或 BC 其中之一。（Pasch 公理​（英语））

set finite_line

fn finite_line_of(a point, b point) finite_line:
    a != b
    then:
        $point_on_line(a, finite_line_of(a, b))
        $point_on_line(b, finite_line_of(a, b))

prop line_intersect_finite_line(a point, b point, l line):
    dom:
        a != b

know forall a point, b point, l line:
    a != b
    $line_intersect_finite_line(a, b, l)
    then:
        $line_intersect_finite_line(b, a, l)

prop line_intersect_line(a point, b point, l line):
    dom:
        a != b
        l != finite_line_of(a, b)

know forall a point, b point, l line:
    a != b
    $line_intersect_line(a, b, l)
    then:
        $line_intersect_line(b, a, l)

know prop line_intersect_finite_line_then_line_intersect_line(a point, b point, c point, l line):
    dom:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)
    iff:
        or:
            $line_intersect_finite_line(a , c, l)
            $line_intersect_finite_line(b , c, l)

prove:
    obj a point, b point, c point, l line:
        a != b
        a != c
        b != c
        $line_intersect_finite_line(a, b, l)

    $line_intersect_finite_line_then_line_intersect_line(a, b, c, l)

    know not $line_intersect_finite_line(a, c, l)
    $line_intersect_finite_line(b, c, l)

# 等同型定理

# 1. 若点 A、B 在直线 a 上且点 A' 在直线 a' 上（可与 a 相同），总可以在 a' 上关于 A' 的任意一侧找到点 B'，使得线段 AB 与 A'B' 等同。这记作 AB ≅ A'B'。 每条线段均与其自身等同，也就是说 AB ≅ AB。（自反性） 此公理就是在说，给定任意线段，可以将其“摆”在任意直线上的任意点的任意一侧。
# 1. If A, B are two points on a line a, and if A′ is a point upon the same or another line a′, then, upon a given side of A′ on the straight line a′, we can always find a point B′ so that the segment AB is congruent to the segment A′B′. We indicate this relation by writing AB ≅ A′B′. Every segment is congruent to itself; that is, we always have AB ≅ AB.
# We can state the above axiom briefly by saying that every segment can be laid off upon a given side of a given point of a given straight line in at least one way.

prop finite_line_equal(l1 finite_line, l2 finite_line)

know forall l1 finite_line, l2 finite_line:
    l1 = l2
    then:
        $finite_line_equal(l1, l2)

prop point_left_of_point(a point, b point):
    dom:
        a != b

prop point_right_of_point(a point, b point):
    dom:
        a != b

know forall a point, b point:
    a != b
    then:
        or:
            $point_left_of_point(a, b)
            $point_right_of_point(a, b)

know exist_prop a point st exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_left_of_point(a, b)
        $finite_line_equal(finite_line_of(a, b), l)

know exist_prop a point st exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(b point, l finite_line):
        a != b
        $point_right_of_point(a, b)
        $finite_line_equal(finite_line_of(a, b), l)

know:
    $commutative_prop(finite_line_equal)
    $commutative_fn(line_of)
    $commutative_fn(finite_line_of)

prove:
    obj middle point, l finite_line

    $exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have right  st $exist_point_right_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_right_of_point(right, middle)
    $finite_line_equal(finite_line_of(middle, right), l)

    $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    have left  st $exist_point_left_to_point_with_finite_line_equal_to_given_finite_line(middle, l)
    $point_left_of_point(left, middle)
    $finite_line_equal(finite_line_of(left, middle), l)

    $finite_line_equal(finite_line_of(left, middle), l)
    


# 2. 若线段 AB 同时与线段 A'B'、A''B'' 等同，那么 A'B' 亦等同于 A''B''。（传递性）
know prop finite_line_equal_transitive(l1 finite_line, l2 finite_line, l3 finite_line):
    dom:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    iff:
        $finite_line_equal(l1, l3)

prove:
    obj l1 finite_line, l2 finite_line, l3 finite_line:
        $finite_line_equal(l1, l2)
        $finite_line_equal(l2, l3)
    $finite_line_equal_transitive(l1, l2, l3)
    $finite_line_equal(l1, l3)

# 3. 令 AB、BC 为同一直线上仅共点于 B 的两条线段，以及 A'B'、B'C' 为另一直线（可与前同）上仅共点于 B' 的两条线段；若 AB ≅ A'B' 且 BC ≅ B'C'ou，则 AC ≅ A'C'。

prop on_one_line(a point, b point, c point):
    a != b
    a != c
    b != c
    iff:
        $point_on_line(a, line_of(b, c))

know:
    forall a point, b point, c point:
        a != b
        a != c
        b != c
        $on_one_line(a, b, c)
        then:
            $on_one_line(a, c, b)
            $on_one_line(b, a, c)
            $on_one_line(b, c, a)
            $on_one_line(c, a, b)
            $on_one_line(c, b, a)

know prop addition_keeps_equal_of_finite_lines(a point, b point, c point, a2 point, b2 point, c2 point):
    $on_one_line(a, b, c)
    $on_one_line(a2, b2, c2)
    $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
    $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
    iff:
        $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

prove:
    obj a point, b point, c point, a2 point, b2 point, c2 point:
        $on_one_line(a, b, c)
        $on_one_line(a2, b2, c2)
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))

    $addition_keeps_equal_of_finite_lines(a, b, c, a2, b2, c2)
    $finite_line_equal(finite_line_of(a, c), finite_line_of(a2, c2))

# 4. 令 ∠(h,k) 为一角。给定一端点 O' 的射线 h' 以及其一侧的半平面 α'，α' 上存在且仅存在一条射线 k' 使得 ∠(h,k) 或 ∠(k,h) 与 ∠(h',k') 等同。这记作 ∠(h,k) ≅ ∠(h',k')。

set ray
set half_plane
set angle

prop point_on_ray(a point, r ray)

fn ray_with_end_point_and_direction(a point, r ray) ray:
    dom:
        $point_on_ray(a, r)

prop half_plane_left_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

prop half_plane_to_ray(a point, r ray, p half_plane):
    dom:
        $point_on_ray(a, r)

fn angle_of_two_rays(a point, r1 ray, r2 ray) angle:
    $point_on_ray(a, r1)
    $point_on_ray(a, r2)

prop angle_equal(ang1 angle, ang2 angle)

know exist_prop r2 ray st exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a point, r1 ray, p half_plane, ang angle):
    dom:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)
    iff:    
        $angle_equal(angle_of_two_rays(a, r1, r2), ang)

prove:
    obj a point, r1 ray, p half_plane, ang angle:
        $point_on_ray(a, r1)
        $half_plane_to_ray(a, r1, p)

    $exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a, r1, p, ang)
    have r2  st $exist_a_ray_with_the_same_angel_with_given_ray_and_half_plane(a, r1, p, ang)
    $angle_equal(angle_of_two_rays(a, r1, r2), ang)

# 5. 若角 ∠(h,k) 等同于角 ∠(h',k')，且 ∠(h',k') 等同于角 ∠(h'',k'')，那么 ∠(h,k) 等同于 ∠(h'',k'')。（传递性）

know prop angle_equal_transitive(ang1 angle, ang2 angle, ang3 angle):
    dom:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    iff:
        $angle_equal(ang1, ang3)

know:
    $commutative_prop(angle_equal)

prove:
    obj ang1 angle, ang2 angle, ang3 angle:
        $angle_equal(ang1, ang2)
        $angle_equal(ang2, ang3)
    $angle_equal_transitive(ang1, ang2, ang3)
    $angle_equal(ang1, ang3)

# 6. 若在三角形 ABC 与 A'B'C' 中有 AB ≅ A'B'、AC ≅ A'C'、∠BAC ≅ ∠B'A'C'，那么可以得到 ∠ABC ≅ ∠A'B'C'（替换字母即可知 ∠ACB ≅ ∠A'C'B' 亦成立）。

set triangle

fn triangle_of_points(a point, b point, c point) triangle:
    dom:
        a != b
        a != c
        b != c

prop triangle_equal(t1 triangle, t2 triangle)

fn angle_of_points(a point, b point, c point) angle:
    dom:
        a != b
        a != c
        b != c

know forall a point, b point, c point:
    a != b
    a != c
    b != c
    then:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, b, c))
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a, c, b))
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, a, c))
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(b, c, a))
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, a, b))
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(c, b, a))

know prop triangle_equal_by_two_sides_and_included_angle_equal(a point, b point, c point, a2 point, b2 point, c2 point):
    dom:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))
    iff:
        $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))
prove:
    obj a point, b point, c point, a2 point, b2 point, c2 point:
        a != b
        a != c
        b != c
        a2 != b2
        a2 != c2
        b2 != c2
        $finite_line_equal(finite_line_of(a, b), finite_line_of(a2, b2))
        $finite_line_equal(finite_line_of(b, c), finite_line_of(b2, c2))
        $angle_equal(angle_of_points(a, b, c), angle_of_points(a2, b2, c2))

    $triangle_equal_by_two_sides_and_included_angle_equal(a, b, c, a2, b2, c2)
    $triangle_equal(triangle_of_points(a, b, c), triangle_of_points(a2, b2, c2))

# 4. 平行型定理

# 1. 对于直线 a 与其外一点 A，其二者所确定的平面内至多有一条直线经过 A 而不与 a 相交。（欧几里得公理）

prop parallel(l1 line, l2 line):
    forall x point:
        $point_on_line1_then_not_on_line2(x, l1, l2)
    
    forall x point:
        $point_on_line1_then_not_on_line2(x, l2, l1)


prop point_on_line1_then_not_on_line2(a point, l1 line, l2 line):
    dom:
        $point_on_line(a, l1)
    iff:
        not $point_on_line(a, l2)

know exist_prop l2 line st exist_one_and_only_one_line_through_point_not_intersect_line(a point, l line):
    dom:
        not $point_on_line(a, l)
    iff:
        $point_on_line(a, l2)
        $parallel(l, l2)

prove:
    obj a point, l line:
        not $point_on_line(a, l)

    $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    have l2 st $exist_one_and_only_one_line_through_point_not_intersect_line(a, l)
    $point_on_line(a, l2)
    $parallel(l, l2)

# 5. 连续型公理

# 1. 令 AB、CD 为任意两条线段，总存在一数 n，使得从 A 出发沿射线 AB 连续构造的 n 条与 CD 等同的线段会经过 B。（阿基米德公理）

set direction

fn direction_of_two_points(a point, b point) direction:
    dom:
        a != b

fn finite_line_of_direction_and_length(a point, d direction, n real) finite_line:
    dom:
        n > 0

know exist_prop n real st exist_finite_line_of_direction_and_length(a point, d direction, l finite_line):
    $finite_line_equal(finite_line_of_direction_and_length(a, d, n), l)

prove:
    obj a point, d direction, l finite_line

    $exist_finite_line_of_direction_and_length(a, d, l)
    have n st $exist_finite_line_of_direction_and_length(a, d, l)
    $finite_line_equal(finite_line_of_direction_and_length(a, d, n), l)

# 2. 欲从既有直线上的点构造新的直线，使得其仍然满足原先元素之间的关系且符合公理一到三以及四-1，这样的尝试是不可能的。（直线完备性公理）
# 2. Axiom of line completeness: An extension (An extended line from a line that already exists, usually used in geometry) of a set of points on a line with its order and congruence relations that would preserve the relations existing among the original elements as well as the fundamental properties of line order and congruence that follows from Axioms I-III and from V-1 is impossible.

# TODO